{
  "name": "jayson",
  "version": "1.1.1",
  "description": "JSON-RPC 1.0/2.0 compliant server and client",
  "keywords": [
    "jsonrpc",
    "rpc",
    "json",
    "jsonrpc-2.0",
    "jsonrpc-1.0",
    "middleware",
    "connect",
    "express",
    "jquery",
    "fork",
    "distributed",
    "relay",
    "http",
    "tcp",
    "https",
    "tls",
    "api"
  ],
  "author": {
    "name": "Tedde Lundgren",
    "email": "mail@tedeh.net",
    "url": "http://tedeh.net"
  },
  "maintainers": "Tedde Lundgren <mail@tedeh.net> (http://tedeh.net)",
  "bin": {
    "jayson": "./bin/jayson.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/tedeh/jayson.git"
  },
  "homepage": "http://jayson.tedeh.net",
  "bugs": {
    "url": "https://github.com/tedeh/jayson/issues"
  },
  "main": "index",
  "engines": {
    "node": ">= 0.4.0"
  },
  "contributors": [
    {
      "name": "Tedde Lundgren",
      "email": "mail@tedeh.net",
      "url": "http://tedeh.net"
    },
    {
      "name": "Daniel Vicory",
      "email": "dvicory@gmail.com",
      "url": "http://bzfx.net"
    },
    {
      "name": "Jonathan Liu",
      "email": "net147@gmail.com"
    }
  ],
  "scripts": {
    "test": "make test"
  },
  "dependencies": {
    "JSONStream": "0.8.0",
    "commander": "1.3.2",
    "eyes": "0.1.8",
    "underscore": "^1.6.0"
  },
  "devDependencies": {
    "should": "*",
    "mocha": "*",
    "connect": "*",
    "uglify-js": "*",
    "blanket": "*"
  },
  "readme": "# Jayson\n\nJayson is a [JSON-RPC 2.0][jsonrpc-spec] compliant server and client written in JavaScript for [node.js][node.js] that aims to be as simple as possible to use.\n\n[jsonrpc-spec]: http://jsonrpc.org/spec.html \n[jsonrpc1-spec]: http://json-rpc.org/wiki/specification\n[node.js]: http://nodejs.org/\n[travis]: https://travis-ci.org/tedeh/jayson\n[travis-img]: https://travis-ci.org/tedeh/jayson.png?branch=master\n\n**Build status:** [![Build Status][travis-img]][travis] \n\n## Table of contents\n\n- [Features](#features)\n- [Example](#example)\n- [Installation](#installation)\n- [Changelog](#changelog)\n- [Requirements](#requirements)\n- [Class Documentation](#class-documentation)\n- [Running tests](#running-tests)\n- [Usage](#usage)\n  - [Client](#client)\n     - [Interface description](#client-interface-description)\n     - [Notifications](#notifications)\n     - [Batches](#batches)\n     - [Callback syntactic sugar](#client-callback-syntactic-sugar)\n     - [Events](#client-events)\n  - [Server](#server)\n     - [Interface description](#server-interface-description)\n     - [Using many interfaces at the same time](#using-many-server-interfaces-at-the-same-time)\n     - [Using the server as a relay](#using-the-server-as-a-relay)\n     - [Method routing](#method-routing)\n     - [Events](#server-events)\n     - [Errors](#server-errors)\n- [Revivers and replacers](#revivers-and-replacers)\n- [Named parameters](#named-parameters)\n- [Contributing](#contributing)\n\n## Features\n\n* Servers that can listen to several interfaces at the same time\n* Supports both HTTP and TCP client and server connections\n* Server-side method - [Method routing]\n* jQuery client\n* Relaying of requests to other servers\n* JSON reviving and replacing for transparent serialization of complex objects\n* CLI client\n* Fully tested to comply with the [official JSON-RPC 2.0 specification][jsonrpc-spec]\n* Also supports [JSON-RPC 1.0][jsonrpc1-spec]\n\n## Example\n\nA basic JSON-RPC 2.0 server via HTTP:\n\nServer in `examples/simple_example/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\n// create a server\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n});\n\n// Bind a http interface to the server and let it listen to localhost:3000\nserver.http().listen(3000);\n```\n\nClient in `examples/simple_example/client.js` invoking `add` on the above server:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\n// create a client\nvar client = jayson.client.http({\n  port: 3000,\n  hostname: 'localhost'\n});\n\n// invoke \"add\"\nclient.request('add', [1, 1], function(err, error, response) {\n  if(err) throw err;\n  console.log(response); // 2!\n});\n```\n\n## Installation\n\nInstall the latest version of _jayson_ from [npm](https://github.com/isaacs/npm) by executing `npm install jayson` in your shell. Do a global install with `npm install --global jayson` if you want the `jayson` client CLI in your PATH.\n\n## Changelog\n\n- *1.1.0*\n  - More http server events\n  - Remove fork server and client\n  - Add server routing\n- *1.0.11*\n  Add support for a HTTPS client\n- *1.0.10*\n  Bugfixes\n- *1.0.9*\n  Add support for TCP servers and clients\n\n### CLI client\n\nThere is a CLI client in `bin/jayson.js` and it should be available as `jayson` in your shell if you installed the package with the `--global` switch. Run `jayson --help` to see how it works.\n\n## Requirements\n\nJayson does not have any special dependencies that cannot be resolved with a simple `npm install`. It has been tested with the following node.js versions:\n\n- node.js v0.8.x\n- node.js v0.10.x\n\n## Class documentation\n\nIn addition to this document, a comprehensive class documentation made with [jsdoc][jsdoc-spec] is available at [jayson.tedeh.net](http://jayson.tedeh.net).\n\n[jsdoc-spec]: http://usejsdoc.org/\n\n## Running tests\n\n- Change directory to the repository root\n- Install the testing framework\n  ([mocha](https://github.com/visionmedia/mocha) together with\n  [should](https://github.com/visionmedia/should.js)) by executing `npm install\n  --dev`\n- Run the tests with `make test` or `npm test`\n\n## Usage\n\n### Client\n\nThe client is available as the `Client` or `client` property of `require('jayson')`.\n\n#### Client interface description\n\n* `Client` Base class for interfacing with a server.\n* `Client.tcp` TCP interface.\n* `Client.http` HTTP interface.\n* `Client.https` HTTPS interface.\n* `Client.jquery` Wrapper around `jQuery.ajax`.\n\nEvery client supports these options:\n\n* `reviver` -> Function to use as a JSON reviver\n* `replacer` -> Function to use as a JSON replacer\n* `generator` -> Function to generate request ids with. If omitted, Jayson will just generate a \"random\" number that is [RFC4122][rfc_4122_spec] compliant and looks similar to this: `3d4be346-b5bb-4e28-bc4a-0b721d4f9ef9`\n* `version` -> Can be either `1` or `2` depending on which specification should be followed in communicating with the server. Defaults to `2` for [JSON-RPC 2.0][jsonrpc-spec]\n\n[rfc_4122_spec]: http://www.ietf.org/rfc/rfc4122.txt\n\n##### Client.http\n\nUses the same options as [http.request][nodejs_docs_http_request] in addition to these options:\n\n* `encoding` -> String that determines the encoding to use and defaults to utf8\n\nIt is possible to pass a string URL as the first argument. The URL will be run through [url.parse][nodejs_docs_url_parse]. Example:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar client = jayson.client.http('http://localhost:3000');\n// client.options is now the result of url.parse\n```\n\n[nodejs_docs_http_request]: http://nodejs.org/docs/latest/api/http.html#http_http_request_options_callback\n[nodejs_docs_url_parse]: http://nodejs.org/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost\n\n##### Client.https\n\nUses the same options as [https.request][nodejs_docs_https_request] in addition _to the same options as `Client.http`_. This means it is also possible\nto pass a string URL as the first argument and have it interpreted by [url.parse][nodejs_docs_url_parse].\n\n[nodejs_docs_https_request]: http://nodejs.org/api/all.html#all_https_request_options_callback\n\n##### Client.tcp\n\nUses the same options as the base class.\n\n##### Client.jquery\n\nThe jQuery Client is stand-alone from the other classes and should preferably be compiled with `make compile` which outputs different flavors into the `build` directory. Supports inclusion via AMD. Uses the same options as [jQuery.ajax][jquery_docs_ajax] and exposes itself as $.jayson with the same arguments as `Client.prototype.request`.\n\n[jquery_docs_ajax]: http://api.jquery.com/jQuery.ajax/\n\n#### Notifications\n\nNotification requests are for cases where the reply from the server is not important and should be ignored. This is accomplished by setting the `id` property of a request object to `null`.\n\nClient in `examples/notifications/client.js` doing a notification request:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar client = jayson.client.http({\n  host: 'localhost',\n  port: 3000\n});\n\n// the third parameter is set to \"null\" to indicate a notification\nclient.request('ping', [], null, function(err) {\n  if(err) throw err;\n  // request was received successfully\n});\n```\nA server in `examples/notifications/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  ping: function(callback) {\n    // do something\n    callback();\n  }\n});\n\nserver.http().listen(3000);\n```\n\n##### Notes\n\n* Any value that the server returns will be discarded when doing a notification request.\n* Omitting the third argument `null` to `Client.prototype.request` does not generate a notification request. This argument has to be set explicitly to `null` for this to happen.\n* Network errors and the like will still reach the callback. When the callback is invoked (with or without error) one can be certain that the server has received the request.\n* See the [Official JSON-RPC 2.0 Specification][jsonrpc-spec] for additional information on how Jayson handles notifications that are erroneous.\n\n#### Batches\n\nA batch request is an array of individual requests that are sent to the server as one. Doing a batch request is very simple in Jayson and consists of constructing an `Array` of individual requests (created by not passing a callback to `Client.prototype.request`) that is then itself passed to `Client.prototype.request`. \n\nClient example in `examples/batch_request/client.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar client = jayson.client.http({\n  host: 'localhost',\n  port: 3000\n});\n\nvar batch = [\n  client.request('does_not_exist', [10, 5]),\n  client.request('add', [1, 1]),\n  client.request('add', [0, 0], null) // a notification\n];\n\n// callback takes two arguments (first type of callback)\nclient.request(batch, function(err, responses) {\n  if(err) throw err;\n  // responses is an array of errors and successes together\n  console.log('responses', responses);\n});\n\n// callback takes three arguments (second type of callback)\nclient.request(batch, function(err, errors, successes) {\n  if(err) throw err;\n  // errors is an array of the requests that errored\n  console.log('errors', errors);\n  // successes is an array of requests that succeded\n  console.log('successes', successes);\n});\n```\n\nServer example in `examples/batch_request/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n});\n\nserver.http().listen(3000);\n```\n\n##### Notes\n\n* See the [Official JSON-RPC 2.0 Specification][jsonrpc-spec] for additional information on how Jayson handles different types of batches, mainly with regards to notifications, request errors and so forth.\n* There is no guarantee that the results will be in the same order as request Array `request`. To find the right result, compare the ID from the request with the ID in the result yourself.\n\n#### Client callback syntactic sugar\n\nWhen the length (number of arguments) of a client callback function is either 2 or 3 it receives slightly different values when invoked.\n\n* 2 arguments: first argument is an error or `null`, second argument is the response object as returned (containing _either_ a `result` or a `error` property) or `null` for notifications.\n* 3 arguments: first argument is an error or null, second argument is a JSON-RPC `error` property or `null` (if success), third argument is a JSON-RPC `result` property or `null` (if error).\n\nWhen doing a batch request with a 3-length callback, the second argument will be an array of requests with a `error` property and the third argument will be an array of requests with a `result` property.\n\n#### Client events\n\nA client will emit the following events (in addition to any special ones emitted by a specific interface):\n\n* `request` Emitted when a client is just about to dispatch a request. First argument is the request object.\n* `response` Emitted when a client has just received a reponse. First argument is the request object, second argument is the response as received.\n\n### Server\n\nThe server classes are available as the `Server` or `server` property of `require('jayson')`.\n\nThe server also sports several interfaces that can be accessed as properties of an instance of `Server`.\n\n#### Server interface description\n\n* `Server` - Base interface for a server that supports receiving JSON-RPC 2.0 requests.\n* `Server.tcp` - TCP server that inherits from [net.Server][nodejs_doc_net_server].\n* `Server.http` - HTTP server that inherits from [http.Server][nodejs_doc_http_server].\n* `Server.https` - HTTPS server that inherits from [https.Server][nodejs_doc_https_server].\n* `Server.middleware` - Method that returns a [Connect][connect]/[Express][express] compatible middleware function.\n\n[nodejs_doc_net_server]: http://nodejs.org/docs/latest/api/net.html#net_class_net_server\n[nodejs_doc_http_server]: http://nodejs.org/docs/latest/api/http.html#http_class_http_server\n[nodejs_doc_https_server]: http://nodejs.org/docs/latest/api/https.html#https_class_https_server\n[connect]: http://www.senchalabs.org/connect/\n[express]: http://expressjs.com/\n\nEvery server supports these options:\n\n* `reviver` -> Function to use as a JSON reviver\n* `replacer` -> Function to use as a JSON replacer\n* `router` -> Function to find which method to use for a request. See the chapter on [method routing](#method-routing).\n* `version` -> Can be either `1` or `2` depending on which specification clients are expected to follow. Defaults to `2` for [JSON-RPC 2.0][jsonrpc-spec]\n\n##### Server.tcp\n\nUses the same options as the base class. Inherits from [net.Server][nodejs_doc_net_server].\n\n##### Server.http\n\nUses the same options as the base class. Inherits from [http.Server][nodejs_doc_http_server].\n\n###### Events\n\nThe HTTP server will emit the following events:\n\n* `http request` Emitted when the server has just created a HTTP request. First argument is an instance of `http.ClientRequest`\n* `http response` Emitted when the server has received an HTTP response. First argument is an instance of `http.IncomingMessage` and second argument an instance of `http.ClientRequest`.\n* `http error` Emitted when the underlying stream emits `error`. First argument is the error.\n\n##### Server.https\n\nUses the same options as the base class. Inherits from [https.Server][nodejs_doc_https_server] and `jayson.Server.http`. For information on how to configure certificates, [see the documentation on https.Server][nodejs_doc_https_server].\n\n##### Server.middleware\n\nUses the same options as the base class. Returns a function that is compatible with [Connect][connect] or [Express][express]. Will expect the request to be `req.body`, meaning that the request body must be parsed (typically using `connect.bodyParser`) before the middleware is invoked.\n\nMiddleware example in `examples/middleware/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar connect = require('connect');\nvar app = connect();\n\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n});\n\n// parse request body before the jayson middleware\napp.use(connect.bodyParser());\napp.use(server.middleware());\n\napp.listen(3000);\n````\n\n#### Using many server interfaces at the same time\n\nA Jayson server can use many interfaces at the same time.\n\nServer in `examples/many_interfaces/server.js` that listens to both `http` and a `https` requests:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    return callback(null, a + b);\n  }\n});\n\n// \"http\" will be an instance of require('http').Server\nvar http = server.http();\n\n// \"https\" will be an instance of require('https').Server\nvar https = server.https({\n  //cert: require('fs').readFileSync('cert.pem'),\n  //key require('fs').readFileSync('key.pem')\n});\n\nhttp.listen(80, function() {\n  console.log('Listening on *:80')\n});\n\nhttps.listen(443, function() {\n  console.log('Listening on *:443')\n});\n```\n\n#### Using the server as a relay\n\nPassing an instance of a client as a method to the server makes the server relay incoming requests to wherever the client is pointing to. This might be used to delegate computationally expensive functions into a separate server or to abstract a cluster of servers behind a common interface.\n\nPublic server in `examples/relay/server_public.js` listening on `*:3000`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\n// create a server where \"add\" will relay a localhost-only server\nvar server = jayson.server({\n  add: jayson.client.http({\n    hostname: 'localhost',\n    port: 3001\n  })\n});\n\n// let the server listen to *:3000\nserver.http().listen(3000, function() {\n  console.log('Listening on *:3000');\n});\n```\n\nPrivate server in `examples/relay/server_private.js` listening on localhost:3001:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n});\n\n// let the private server listen to localhost:3001\nserver.http().listen(3001, '127.0.0.1', function() {\n  console.log('Listening on 127.0.0.1:3001');\n});\n```\n\nEvery request to `add` on the public server will now relay the request to the private server. See the client example in `examples/relay/client.js`.\n\n#### Method routing\n\nPassing a property named `router` in the server options will enable you to write your own logic for routing requests to specific functions. \n\nServer with custom routing logic in `examples/method_routing/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar format = require('util').format;\n\nvar methods = {\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n};\n\nvar server = jayson.server(methods, {\n  router: function(method) {\n    // regular by-name routing first\n    if(typeof(this._methods[method]) === 'function') return this._methods[method];\n    if(method === 'add_2') return this._methods.add.bind(this, 2);\n  }\n});\n```\n\nClient in `examples/method_routing/client.js` invoking `add_2` on the above server:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\n// create a client\nvar client = jayson.client.http({\n  port: 3000,\n  hostname: 'localhost'\n});\n\n// invoke \"add_2\"\nclient.request('add_2', [3], function(err, error, response) {\n  if(err) throw err;\n  console.log(response); // 5!\n});\n```\n\nAn example of nested routes where each property is separated by a dot (you do not need to use the router option for this):\n\n```javascript\nvar _ = require('underscore');\nvar jayson = require(__dirname + '/../..');\n\nvar methods = {\n  foo: {\n    bar: function(callback) {\n      callback(null, 'ping pong');\n    }\n  },\n  math: {\n    add: function(a, b, callback) {\n      callback(null, a + b);\n    }\n  }\n};\n\n// this reduction produces an object like this: {'foo.bar': [Function], 'math.add': [Function]}\nvar map = _.reduce(methods, collapse('', '.'), {});\nvar server = jayson.server(map);\n\nfunction collapse(stem, sep) {\n  return function(map, value, key) {\n    var prop = stem ? stem + sep + key : key;\n    if(_.isFunction(value)) map[prop] = value;\n    else if(_.isObject(value)) map = _.reduce(value, collapse(prop, sep), map);\n    return map;\n  }\n}\n\n```\n\n##### Notes\n\n* If `router` does not return anything, the reserver will respond with a `Method Not Found` error.\n* The `Server.prototype` methods `method`, `methods`, `removeMethod` and `hasMethod` will not use the `router` method, but will operate on the internal `Server.prototype._methods` map.\n\n#### Server events\n\nIn addition to events that are specific to certain interfaces, all servers will emit the following events:\n\n* `request` Emitted when the server receives an interpretable (non-batch) request. First argument is the request object.\n* `response` Emitted when the server is returning a response. First argument is the request object, the second is the response object.\n* `batch` Emitted when the server receives a batch request. First argument is an array of requests. Will emit `request` for each interpretable request in the batch.\n\n#### Server Errors\n\nIf you should like to return an error from an method request to indicate a failure, remember that the [JSON-RPC 2.0][jsonrpc-spec] specification requires the error to be an `Object` with a `code (Integer/Number)` to be regarded as valid. You can also provide a `message (String)` and a `data (Object)` with additional information. Example: \n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  i_cant_find_anything: function(id, callback) {\n    var error = {code: 404, message: 'Cannot find ' + id};\n    callback(error); // will return the error object as given\n  },\n  i_cant_return_a_valid_error: function(callback) {\n    callback({message: 'I forgot to enter a code'}); // will return a pre-defined \"Internal Error\"\n  }\n});\n```\n\n##### Predefined Errors\n\nIt is also possible to cause a method to return one of the predefined [JSON-RPC 2.0 error codes][jsonrpc-spec#error_object] using the server helper function `Server.prototype.error` inside of a server method. Example:\n\n[jsonrpc-spec#error_object]: http://jsonrpc.org/spec.html#error_object\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  invalid_params: function(id, callback) {\n    var error = this.error(-32602); // returns an error with the default properties set\n    callback(error);\n  }\n});\n```\n\nYou can even override the default messages:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  error_giver_of_doom: function(callback) {\n    callback(true) // invalid error format, which causes an Internal Error to be returned instead\n  }\n});\n\n// Override the default message\nserver.errorMessages[Server.errors.INTERNAL_ERROR] = 'I has a sad. I cant do anything right';\n```\n\n### Revivers and Replacers\n\nJSON lacks support for representing types other than the simple ones defined in the [JSON specification][jsonrpc-spec]. Fortunately the JSON methods in JavaScript (`JSON.parse` and `JSON.stringify`) provide options for custom serialization/deserialization routines. Jayson allows you to pass your own routines as options to both clients and servers.\n\nSimple example transferring the state of an object between a client and a server:\n\nShared code between the server and the client in `examples/reviving_and_replacing/shared.js`:\n\n```javascript\nvar Counter = exports.Counter = function(value) {\n  this.count = value || 0;\n};\n\nCounter.prototype.increment = function() {\n  this.count += 1;\n};\n\nexports.replacer = function(key, value) {\n  if(value instanceof Counter) {\n    return {$class: 'counter', $props: {count: value.count}};\n  }\n  return value;\n};\n\nexports.reviver = function(key, value) {\n  if(value && value.$class === 'counter') {\n    var obj = new Counter;\n    for(var prop in value.$props) obj[prop] = value.$props[prop];\n    return obj;\n  }\n  return value;\n};\n```\n\nServer in `examples/reviving_and_replacing/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar shared = require('./shared');\n\n// Set the reviver/replacer options\nvar options = {\n  reviver: shared.reviver,\n  replacer: shared.replacer\n};\n\n// create a server\nvar server = jayson.server({\n  increment: function(counter, callback) {\n    counter.increment();\n    callback(null, counter);\n  }\n}, options);\n\n// let the server listen to for http connections on localhost:3000\nserver.http().listen(3000);\n```\n\nA client in `examples/reviving_and_replacing/client.js` invoking \"increment\" on the server:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\nvar shared = require('./shared');\n\n// create a client with the shared reviver and replacer\nvar client = jayson.client.http({\n  port: 3000,\n  hostname: 'localhost',\n  reviver: shared.reviver,\n  replacer: shared.replacer\n});\n\n// create the object\nvar instance = new shared.Counter(2);\n\n// invoke \"increment\"\nclient.request('increment', [instance], function(err, error, result) {\n  if(err) throw err;\n  console.log(result instanceof shared.Counter); // true\n  console.log(result.count); // 3!\n  console.log(instance === result); // false - it won't be the same object, naturally\n});\n```\n\n#### Notes\n\n* Instead of using a replacer, it is possible to define a `toJSON` method for any JavaScript object. Unfortunately there is no corresponding method for reviving objects (that would not work, obviously), so the _reviver_ always has to be set up manually.\n\n### Named parameters\n\nIt is possible to specify named parameters when doing a client request by passing an Object instead of an Array.\n\nClient example in `examples/named_parameters/client.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../../');\n\nvar client = jayson.client.http({\n  host: 'localhost',\n  port: 3000\n});\n\nclient.request('add', {b: 1, a: 2}, function(err, error, response) {\n  if(err) throw err;\n  console.log(response); // 3!\n});\n\n```\n\nServer example in `examples/named_parameters/server.js`:\n\n```javascript\nvar jayson = require(__dirname + '/../..');\n\nvar server = jayson.server({\n  add: function(a, b, callback) {\n    callback(null, a + b);\n  }\n});\n\nserver.http().listen(3000);\n```\n\n#### Notes\n\n* If requesting methods on a Jayson server, arguments left out will be `undefined`\n* Too many arguments or arguments with invalid names will be ignored\n* It is assumed that the last argument to a server method is the callback and it will not be filled with something else\n\n### Contributing\n\nHighlighting [issues](https://github.com/tedeh/jayson/issues) or submitting pull\nrequests on [Github](https://github.com/tedeh/jayson) is most welcome.\n",
  "readmeFilename": "README.md",
  "_id": "jayson@1.1.1",
  "_from": "jayson@"
}
